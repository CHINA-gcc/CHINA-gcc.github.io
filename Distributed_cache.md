# 分布式缓存

## Memcached
- Memcached 是一个开源的、高性能的分布式 key/value 内存缓存系统. 它以 key/value 键值对的方式存储数据, 是一个键值类型的 NoSQL (聚合模型处理数据)组件.
### Mc特性
- ① Mc 最大的特性是高性能, 单节点压测性能达到百万级的 QPS.
- ② Mc 的访问协议很简单(与存储结构有关), 只有 get/set/cas/touch/gat/stats 等有限的几个命令.
- ③ Mc 存储结构很简单, 只存储简单的 key/value 键值对. 只能支持二进制字节块这一种数据类型, 不识别内部存储结构.
- ④ Mc 完全基于内存操作. 在系统运行期间, 有新 key 写进来时, 如果没有空闲内存分配, 就会对最不活跃的 key 进行 eviction 剔除操作.
- ⑤ Mc 服务节点运行也特别简单, Mc 组件之间相互不通信, 完全由 client 对 key 进行 Hash 后分布和协同. Mc 采用多线程处理请求, 由一个主线程和任意多个工作线程协作. 从而充分利用多核, 提升 IO 效率.
### slab
- Mc 内的内存分配以 slab(默认1MB) 为单位, 可以通过 -I 参数在启动时指定其它数值.
- Mc 在分配内存时, 先将内存按固定大小划分成 slab, 在 slab 空间内部 分拆出固定 size 的 chunk(不同 slab 的 chunk size 并不同). Mc 会按照一个固定比例, 使划分的 chunk size 逐步增大, 从而满足不同大小 key/value 存储的需要. 每个 chunk 内部存储一个 item(利用 Item 结构存储数据).
> 因为 chunk 大小固定，而 key/value 数据的大小随机. 所以, Item存储完 key/value 数据后, 一般还会有多余的空间. 为了提升内存的使用效率, chunk size 不能太大.  而要尽量选择与 key/value size 接近的, 从而减少 chunk 内浪费的空间.
### 系统架构
- Mc 基于 Libevent 实现了网络处理模块; 通过多线程并发处理用户请求; 基于哈希表对 key 进行快速定位; 基于 LRU 来管理冷数据的剔除淘汰; 基于 slab 机制进行快速的内存分配及存储。
## Redis
- 单线程压测可以达到 10~11w 的 QPS.
- Redis 所有数据的读写操作都在内存中进行. 但可以将所有数据进行落盘做持久化.
> ① 快照方式，将某时刻所有数据都写入硬盘的 RDB 文件.
> ② 追加文件方式，即将所有写命令都以追加的方式写入硬盘的 AOF 文件中.

- 线上 Redis 一般会同时使用两种方式，通过开启 appendonly 及关联配置项，将写命令及时追加到 AOF 文件，同时在每日流量低峰时，通过 bgsave 保存当时所有内存数据快照。 
> (微博读写操作)可以使用 Redis 的复制特性, 让一个 Redis 实例作为 master, 然后通过复制挂载多个不断同步更新的副本, 即多个 slave. 通过读写分离把所有写操作落在 Redis 的 master, 所有读操作随机落在 Redis 的多个 slave 中, 从而大幅提升 Redis 的读写能力.

### 系统架构
#### 事件处理机制
#### 数据存储及管理
- Redis 的内存数据都存在 redisDB 中(每个 DB 都对应一个 redisDB 结).
- Redis 的 8 种数据类型, 每种数据类型都采用一种或多种内部数据结构进行存储. 同时这些内部数据结构及数据相关的辅助信息都以 key/value 的格式存在 redisDB 中的各个 dict 字典中.
- 数据在写入 redisDB 后, 这些执行的写指令还会及时追加到 AOF 中. 追加的方式是先实时写入AOF 缓冲, 然后按策略刷缓冲数据到文件. 由于 AOF 记录每个写操作, 所以一个 key 的大量中间状态也会呈现在 AOF 中, 导致 AOF 冗余信息过多. 因此 Redis 还设计了一个 RDB 快照操作, 可以通过定期将内存里所有的数据快照落地到 RDB 文件来以最简洁的方式记录 Redis 的所有内存数据.
- Redis 进行数据读写的核心处理线程是单线程模型, 为了保持整个系统的高性能, 必须避免任何kennel 导致阻塞的操作. Redis 增加了 BIO 线程, 来处理容易导致阻塞的文件 close、fsync 等操作, 确保系统处理的性能和稳定性.
- Redis 中, 过期的 key 需要及时清理. 不活跃的 key 在内存不足时也可能需要进行淘汰. 为此, Redis 设计了 8 种淘汰策略. 借助新引入的 eviction pool，进行高效的 key 淘汰和内存回收.
系统扩展

为插件化功能扩展的 Module System 模块

- Redis 的事件驱动模型机制封装在 aeEventLoop 等相关的结构体中, 处理文件事件(连接建立、接受请求命令、发送响应等)和时间事件( Redis 中定期要执行的统计、key 淘汰、缓冲数据写出、rehash).
- Redis 的文件事件采用典型的 Reactor 模式进行处理.
- 连接 socket
> 文件事件是对连接 socket 操作的一个抽象. 当端口监听 socket 准备 accept 新连接或者连接 socket 准备好读取请求、写入响应、关闭时会产生一个文件事件. IO 多路复用程序负责同时监听多个 socket. 当这些 socket 产生文件事件时会触发事件通知, 文件分派器就会感知并获取到这些事件.
- IO 多路复用程序
> Redis 封装了 4 种多路复用程序, 每种封装实现都提供了相同的 API 实现. 编译时会按照性能和系统平台选择最佳的 IO 多路复用函数作为底层实现(首先尝试选择 Solaries 中的 evport, 如果没有就尝试选择 Linux 中的 epoll. 否则选择大多 UNIX 系统都支持的 kqueue. 这 3 个多路复用函数都直接使用系统内核内部的结构，可以服务数十万的文件描述符.)
> 如果当前编译环境没有上述函数就会选择 select 作为底层实现方案. select 方案的性能较差. 事件发生时会扫描全部监听的描述符(事件复杂度是 O(n)), 并且只能同时服务有限个文件描述符. 32 位机默认是 1024 个，64 位机默认是 2048 个. 所以一般情况下并不会选择 select 作为线上运行方案. 
- Redis 的这 4 种实现，分别在 ae_evport、ae_epoll、ae_kqueue 和 ae_select 这 4 个代码文件中。
- 文件事件收集及派发器
> Redis 中的文件事件分派器是 aeProcessEvents 函数. 它会首先计算最大可以等待的时间, 然后利用 aeApiPoll 等待文件事件的发生. 如果在等待时间内一旦 IO 多路复用程序产生了事件通知, 则会立即轮询所有已产生的文件事件并将文件事件放入 aeEventLoop 中的 aeFiredEvents 结构数组中. 每个 fired event 会记录 socket 及 Redis 读写事件类型.
事件处理器







- Redis 当前的主要时间事件处理函数有 serverCron、moduleTimerHandler.
- Redis 中的时间事件分为单次时间(执行完毕后该时间事件就结束了)和周期性事件(在事件执行完毕后会继续设置下一次执行的事件. 从而在时间到达后继续执行, 并不断重复).
> 时间事件属性
① 事件 ID(Redis 为时间事件创建全局唯一 ID, 该 ID 按从小到大的顺序进行递增.)
② 执行时间 when_sec 和 when_ms(精确到毫秒, 记录该事件的到达可执行时间.)
③ 时间事件处理器 timeProc(在时间事件到达时Redis 会调用相应的 timeProc 处理事件.)
④ 关联数据 clientData(在调用 timeProc 时需要使用该关联数据作为参数.)
⑤ 链表指针 prev 和 next(它用来将时间事件维护为双向链表, 便于插入及查找所要执行的时间事件.)

- 时间事件的处理是在事件循环中的 aeProcessEvents 中进行.
> ① 遍历所有的时间事件.
② 比较事件的时间和当前时间，找出可执行的时间事件.
③ 执行时间事件的 timeProc 函数.
④ 执行完毕后, 对于周期性时间设置时间新的执行时间. 对于单次性时间, 设置事件的 ID为 -1, 后续在事件循环中, 下一次执行 aeProcessEvents 的时候从链表中删除.

### Redis协议解析及处理
### Redis 淘汰 key
- Redis 的内存阀值是通过 maxmemory 设置的, 而超过内存阀值后的淘汰策略是通过 maxmemory-policy 设置的.
- Redis 会在 2 种场景下对 key 进行检查淘汰(定期执行 serverCron 时 / 执行命令时).
> Redis 定期执行 serverCron时, 首先轮询每个 DB，检查其 expire dict，即带过期时间的过期 key 字典，从所有带过期时间的 key 中，随机选取 20 个样本 key，检查这些 key 是否过期，如果过期则清理删除。如果 20 个样本中，超过 5 个 key 都过期，即过期比例大于 25%，就继续从该 DB 的 expire dict 过期字典中，再随机取样 20 个 key 进行过期清理，持续循环，直到选择的 20 个样本 key 中，过期的 key 数小于等于 5，当前这个 DB 则清理完毕，然后继续轮询下一个 DB.
> 执行 serverCron 时, 如果在某个 DB 中过期 dict 的填充率低于 1%则放弃对该 DB 的取样检查(效率太低). 
> 如果 DB 的过期 dict 中过期 key 太多, 一直持续循环回收会占用大量主线程时间. 所以 Redis 还设置了一个过期时间. 过期时间根据 serverCron 的执行频率来计算, 5.0 版本及之前采用慢循环过期策略(默认是 25ms). 如果回收超过 25ms 则停止. 6.0 非稳定版本采用快循环策略, 过期时间为 1ms.

#### 淘汰方式
- Redis 中 key 的淘汰方式分别是同步删除淘汰和异步删除淘汰.
- 在 serverCron 定期清理过期 key 时, 如果设置了延迟过期配置 lazyfree-lazy-expire, 会检查 key 对应的 value 是否为多元素的复合类型, 即是否是 list 列表、set 集合、zset 有序集合和 hash 中的一种, 并且 value 的元素数大于 64. 则在将 key 从 DB 中 expire dict 过期字典和主 dict 中删除后, value 存放到 BIO 任务队列, 由 BIO 延迟删除线程异步回收. 
- 否则，直接从 DB 的 expire dict 和主 dict 中删除, 并回收 key、value 所占用的空间. 在执行命令时, 如果设置了 lazyfree-lazy-eviction, 在淘汰 key 时也采用前面类似的检测方法. 对于元素数大于 64 的 4 种复合类型, 使用 BIO 线程异步删除. 否则采用同步直接删除.

